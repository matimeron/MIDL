Function Hihar_ratio, ene, uharm = uhr, mharm = mhr, all = all, $
	period = per, aperture = ape, distance = dst, $
	ncrystal = ncr, crystal = crs, index = ind, $
	nmirror = nmr, mirror = mir, angle = ang, roughness = rof, _extra = _e

;+
; NAME:
;		HIHAR_RATIO
; VERSION:
;		8.2
; PURPOSE:
;		Calculates the flux ratios of higher monochromator harmonics to the
;		fundamental.
; CATEGORY:
;		X-ray, undulator specific.
; CALLING SEQUENCE:
;		Result = HIHAR_RATIO( ENE, UHARM = UHR [, keywords])
; INPUTS:
;	ENE
;		Photon energy(s) in keV, scalar or vector.
; OPTIONAL INPUT PARAMETERS:
;		None.
; KEYWORD PARAMETERS:
; 	UHARM
; 		Odd integer scalar, the undulator harmonic.  Mandatory.
; 	MHARM
; 		Odd integer scalar, the monochromator harmonic (relative to fundamental.
; 		Default is 3.
; 	/ALL
; 		Switch.  If set, an estimate of the combined flux of all the higher 
; 		harmonics is generated.
; 		
; 		Note:	The estimate is generated by an extrapolation from the results
; 				for 3rd, 5th and 7th harmonic.  Usually this is quite sufficient
; 				(in fact 3rd harmonic alone is a good estimate for the total).
; 				The one exception can occur for evaluation for low (1st usually)
; 				undulator harmonic, with no monochromators and no mirrors.  In
; 				this case more terms are needed and this can be done by invoking
; 				"ALL = value" where value is an integer > 3.
;	PERIOD
;		Scalar or vector, the length(s) of the undulator period(s).  If the
;		value(s) is (are) less then 1, lenght in meters is assumed, else in
;		milimeters.  Default value is 33 (mm), the current value for 15ID.
;	APERTURE
;		The aperture for flux calculation, given as a 2-element vector in
;		[x-size,y-size] format, in mm.  If not given, the standard aperture from
;		!BLPAR is used.
;	DISTANCE
;		The distance of the aperture (see above) from source, in meters.  If not
;		given, the standard distance from !BLPAR is used.
;	NCRYSTAL
;		Number of crystals in the beam path.  Serves as multiplyer for the next 
;		two entries if data for a *single* crystal is given, shouldn't be used
;		otherwise.
;	CRYSTAL
;		Character scalar or vector, representing the crystal(s) being used.
;	INDEX
;		A 3-element vector or a [3,*] array, each row contains a set of 3 
;		reflection indices (see routine BRAGG_ANGLE).  The number of rows *must*
;		equal the number of entries in CRYSTAL.
;
;		Note:	The number of entries in CRYSTAL (and of rows in INDEX} is the
;				crystal number NCR.  The folowing rules apply:
;				1)	If NCR is 0, no Bragg reflection is applied.
;				2)	If NCR is 1, NCRYSTAL may be an arbitrary positive integer, 
;					which signifies the number of repetitions of the crystal 
;					being used.  If not given, NCRYSTAL defaults to 2 in this 
;					case.
;				3)	If NCR is not 1, NCRYSTAL serves no purpose and shouldn't be
;					used but, if given, its value should be NCR.  Any other 
;					value will result in an error.
;	NMIRROR
;		The number of mirrors used (same as NCRYSTAL, for mirrors).
;	MIRROR
;		Character scalar or vector representing the mirror(s) being used.
;	ANGLE
;		Numeric scalar or vector, the reflection angle(s) for the mirror(s).
;		*Must* contain one angle for each element in MIRROR.  The angles are
;		assumed to be given in miliradians, unless all the values are <0.01, in
;		which case radians are assumed.
;	ROUGHNESS
;		Numeric scalar or vector, the roughness values (in Angstrem) for the
;		mirrors.  Optional, but if given the number of entries *must* equal the
;		number of mirrors.  Defaults to 0.
;
;		Note:	The number of entries in MIRROR (and in ANGLE and ROUGHNESS} is 
;				the mirror number NMR.  The folowing rules apply:
;				1)	If NMR is 0, no mirror reflection is applied.
;				2)	If NMR is 1, NMIRROR may be an arbitrary positive integer, 
;					which signifies the number of repetitions of the mirror 
;					being used.  If not given, NMIRROR defaults to 2 in this 
;					case.
;				3)	If NMR is not 1, NMIRROR serves no purpose and shouldn't be
;					used but, if given, its value should be NMR.  Any other 
;					value will result in an error.
;	_EXTRA
;		A formal keyword for transfering keywords to UND_FLUX.  Not to be used
;		directly.
; OUTPUTS:
;		Returns the flux ratio(s) of the higher harmonic (usually third, the 
;		default) to the fundamental for each of the energies in ENE.
; OPTIONAL OUTPUT PARAMETERS:
;		None.
; COMMON BLOCKS:
;		None.
; SIDE EFFECTS:
;		None.
; RESTRICTIONS:
;		1)	The energy values used must be within the range achievable for UHARM
;		2)	Number of crystal and mirror parameters must conform to the rules
;			set in the notes above.
; PROCEDURE:
;		Calculates the flux values using UND_FLUX (see there), with bandwidths
;		determined by the crystal(s), while applying both crystal(s) and 
;		mirror(s) reflectivities).  If /ALL is set, HIHAR_RATIO calls itself 
;		recursively.  Calls MIRROR.  Calls BRAGG_ANGLE and REF_CURVE from MONO.
;		Calls DEFAULT, FPU_FIX and SERIES_SUM from MIDL.
; MODIFICATION HISTORY:
;		Created 10-JAN-2013 by Mati Meron.
;-

	on_error, 1

	if keyword_set(all) then begin
		slim = fix(all) > 3
		nen = n_elements(ene)
		buff = fltarr(slim,nen)
		res = fltarr(nen)
		for i = 0, slim-1 do buff[i,*] = $
		Hihar_ratio(ene,uhar=uhr,mhar=2*i+3,per=per,aper=ape,dist=dst,$
		ncrys=ncr,crys=crs,ind=ind,nmir=nmr,mir=mir,ang=ang,rough=rof,_extra=_e)
		for j = 0, nen-1 do res[j] = Series_sum(buff[*,j])
		if (size(ene))[0] eq 0 then res = res[0]
	endif else begin	
		if not (uhr mod 2) then message,'Only odd undulator harmonics accepted!'
		wmhr = Default(mhr,3,/dtyp)
		if not (wmhr mod 2) then message, 'Only odd mono harmonics accepted!'
		wper = Default(per,33.)
	
		necrs = n_elements(crs)
		if necrs gt 0 then begin
			if necrs eq 1 then begin
				wncr = Default(ncr,2l,/dtyp)
				if wncr eq 1 then wcrs = crs else wcrs = replicate(crs,2)
			endif else begin
				wncr = necrs
				if Default(ncr,wncr) eq wncr then wcrs = crs $
				else message, 'Crystal number mismatch!'
			endelse
	
			isiz = size(ind)
			if isiz[0] gt 0 and isiz[1] eq 3 then begin
				if isiz[0] eq 1 then begin
					wind = lonarr(3,wncr)
					for i = 0, wncr-1 do wind[*,i] = ind
				endif else if isiz[0] eq 2 then begin
					if isiz[2] eq wncr then wind = ind $
					else message, 'index mismatch!'
				endif else message, 'Bad crystal index!'
			endif else message, 'Bad or missing crystal index!'
		endif else begin
			if Default(ncr,0) eq 0 then wncr = 0 $
			else message, 'Bad crystal input!'
		endelse
	
		nemir = n_elements(mir)
		if nemir gt 0 then begin
			if nemir eq 1 then begin
				wnmr = Default(nmr,2l,/dtyp)
				if wnmr eq 1 then wmir = mir else wmir = replicate(mir,2)
			endif else begin
				wnmr = nemir
				if Default(nmr,wnmr) eq wnmr then wmir = mir $
				else message, 'Mirror number mismatch!'
			endelse
	
			case n_elements(ang) of
				1	:	wang = replicate(ang,wnmr)
				wnmr:	wang = ang
				else:	message, 'Bad or missing mirror angle input!
			endcase
			if max(wang) gt 1e-1 then wang = 1e-3*wang
	
			case n_elements(rof) of
				0	:	wrof = replicate(0.,wnmr)
				1	:	wrof = replicate(rof,wnmr)
				wnmr:	wrof = rof
				else:	message, 'Bad or missing mirror roughness input!'
			endcase
		endif else begin
			if Default(nmr,0) eq 0 then wnmr = 0 $
			else message, 'Bad mirror input!'
		endelse
	
		hene = wmhr*ene
		lref = (href = (lbw = (hbw = 1.)))
		for i = 0, wncr - 1 do begin
			lref = lref*Ref_curve(0,ene=ene,crys=wcrs[i],ind=wind[*,i])
			href = href*Ref_curve(0,ene=hene,crys=wcrs[i],ind=wmhr*wind[*,i])
			dum = Bragg_angle(ene=ene,crys=wcrs[i],ind=wind[*,i],eta=leta)
			dum = Bragg_angle(ene=hene,crys=wcrs[i],ind=wmhr*wind[*,i],eta=heta)
			lbw = lbw < leta
			hbw = hbw < heta
		endfor
		for i = 0, wnmr - 1 do begin
			lref = lref*Mirror(ene,wang[i],elem=wmir[i],rough=wrof[i])
			href = href*Mirror(hene,wang[i],elem=wmir[i],rough=wrof[i])
		endfor
	
		lo = lref*Und_flux($
			ene,per=wper,harm=uhr,ban=lbw,/def,ape=ape,dist=dst,_extra=_e)
		hi = href*Und_flux($
			hene,per=wper,harm=wmhr*uhr,ban=hbw,/def,ape=ape,dist=dst,_extra=_e)
		res = hi/lo
	endelse

	return, FPU_fix(res)
end