Function Shape_clean, shape, close = clo, tol_mult = tml

;+
; NAME:
;		SHAPE_CLEAN
; VERSION:
;		8.45
; PURPOSE:
;		Modifies a SHAPE (see SHAPE_VER for a definition) by removing dangling
;		zero area "tails" and repeated points.
; CATEGORY:
;		General Graphics.
; CALLING SEQUENCE:
;		Result = SHAPE_CLEAN( SHAPE, [, CLOSE = CLOSE])
; INPUTS:
;	SHAPE
;		Two dimensional shape i.e. a [2,*] numeric array.
; OPTIONAL INPUT PARAMETERS:
;		None.
; KEYWORD PARAMETERS:
;	/CLOSE
;		Switch.  If set, forces closure of the output shape.  If the input
;		shape happens to be closed, the output one is being closed
;		automatically unless CLOSE is explicitly set to zero.
;	TOL_MULT
;		Numeric scalar, tolerance multiplier to be used by the function APPROX.
;		See there for details.
; OUTPUTS:
;		Returns a new shape, generated by removing repeated points and zero area
;		closed loops from the original shape.
;
;		Note:  The returned shape will always have at least 2 points, even if
;		they're identical.  An input shape with less than 3 points won't be
;		processed.
; OPTIONAL OUTPUT PARAMETERS:
; 		None.
; COMMON BLOCKS:
;		None.
; SIDE EFFECTS:
;		None.
; RESTRICTIONS:
;		Shapes with less than 3 points are returned uprocessed.
; PROCEDURE:
; 		Identifies spurious points and zero area loops and removes them.
; 		Repeats the process iteratively till no further modifications occur.
; 		Calls APPROX, CAST, DEFAULT, SHAPE_CLOSE, SHAPE_VER, TOLER and TYPE,
; 		from MIDL.
; MODIFICATION HISTORY:
;		Created 5-SEP-2011 by Mati Meron.
;		Modified 10-SEP-2011 by Mati Meron. Significant rewriting.
;		Modified 15-FEB-2016 by Mati Meron.  Internal changes.
;-

	on_error, 1

	ndim = Shape_ver(shape,length=len)
	if ndim eq 2 then begin
		typ = Type(shape)
		wtml = Default(tml,1) > 1
		eps = 2*wtml*Toler(shape)
		tre = eps*(max(abs(shape[0,*])) + max(abs(shape[1,*])))
		clf = Approx(shape[*,0],shape[*,len-1],thre=tre,/glob)
		len = len - clf
		res = Cast(shape[*,0:len-1],4)
		tre = 0	
		con = len gt 2
		while con and len gt 2 do begin
			x = reform(res[0,*])
			y = reform(res[1,*])
			fir = (x - shift(x,1))*(shift(y,-1) - y)
			sec = (shift(x,-1) - x)*(y - shift(y,1))
			if tre eq 0 then tre = 4*eps*(max(abs(fir)) > max(abs(sec)))
			comp =  Approx(fir,sec,thre=tre)
			bad = (where(comp))[0]
			if bad ge 0 then begin
				stat = replicate(1,len)
				stat[bad] =  0
				res = res[*,where(stat)]
				len = len - 1
			endif else con = 0
		endwhile
		if (clf and Default(clo,1,/dtyp) ne 0) or keyword_set(clo) $
		then res = Shape_close(res)
		res = Cast(res,typ,typ)
	endif else begin
		if ndim eq 3 then message, 'Only 2-D shapes accepted!', /continue $
		else message, 'Improper or missing shape!', /continue
		res = []
	endelse

	return, res
end