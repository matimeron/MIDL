Pro Output, comm, option = opt, device = dev, file = fil, select = sel, $
	full_size = ful, half_size = hlf, quarter_size = qua, blin_size = bln, $
	color = col, print = prn, subst = sub, v_0, v_1, v_2, v_3, v_4, v_5, v_6, $
	v_7, v_8, v_9, v_10, v_11, v_12, v_13, v_14, v_15, _extra = _e

;+
; NAME:
;		OUTPUT
; VERSION:
;		5.2
; PURPOSE:
;		Generic output interface.  Allows sending the results of virtually any
;		IDL command or file to any predefined hard copy device.  In detail,
;		OUTPUT executes the provided command, and sends the output to the
;		specified device, generating a file if needed.
; CATEGORY:
;		Input/Output.
; CALLING SEQUENCE:
;		OUTPUT, COMM [, keywords] [,optional input parameters]
; INPUTS:
;	COMM
;		Character value representing a valid IDL command.  Can be (and usually
;		is) a procedure or function call.
; OPTIONAL INPUT PARAMETERS:
;	V_0 through V_15
;		Serve to pass variables which are used in the command COMM.  Since COMM
;		is passed to output as a single string, OUTPUT is not receiving the
;		values of any variables used by COMM.  If such values are needed they
;		have to be passed separately.  This is done using the variables V_0
;		through V_15 in combination with the keyword SUBST (see below), which
;		accepts a string made of the names of the variables separated by spaces
;		or commas.
;		Example:
;			Assume a routine named NEWPLOT which is called using the syntax
;				NEWPLOT, I, X, SCOPE = Y
;			If at the time of call I, X, and Y have known values, say 3, 12.4
;			and [12,95] then it is possible to issue the command
;				OUTPUT, 'NEWPLOT, 3, 12.4, SCOPE = [12,95]'
;			If, on the other hand one would want to pass NEWPLOT to output
;			using the variables K, E and RANG for I, X, Y, the command can be
;				OUTPUT, 'NEWPLOT, I, X, SCOPE = Y', $
;				SUBST = 'I,X   Y', K, E, RANG
;			The order in which the variable names appear in SUBST is arbitrary
;			but it has to be in a one-to-one correspondence with the order in
;			which the actual arguments are given.  Therefore, the following is
;			equally valid
;				OUTPUT, 'NEWPLOT, I, X, SCOPE = Y', $
;				SUBST = 'Y, I, X', RANG, K, E
; KEYWORD PARAMETERS:
;	OPTION
;		Accepts a string representing a valid IDL command.  If given, this
;		command will be executed BEFORE COMM.  If the command in OPTION
;		includes variables, their values can be passed using the same mechanism
;		as the one used for COMM (see above).
;	DEVICE
;		Accepts a string specifying a graphics device.  Currently accepted
;		devices are:
;			'PRINTER'	-  The default printer.
;			'PS'		-  Writes a PostScript file.
;			'EPS'		-  Writes an encapsulated PostScript file.
;		This list may be extended in the future, as needed.  For all devices on
;		the list only the first two characters of the name are needed as input.
;		If "DEVICE" is not provided, it defaults to "PRINTER" on the first call
;		in a session and to the last used device on all subsequent calls.
;	FILE
;		Accepts a string representing a valid file name.  Extension isn't
;		necessary.  If not given, a file name is generated using date and time.
;		If the "PRINTER" device is being used, the filename is ignored.
;
;		Note:  	When a file name is provided, an interactive GUI will open to
;				aid the user.  This is the default action.  It can be overriden
;				by using the keyword /AUTO which is passed by _EXTRA to
;				FILE_GET.
;	/SELECT
;		Switch.  Works only with the "PRINTER" device.  When set, calls on
;		DIALOG_PRINTERSETUP, enabling the user to select any of the printers
;		recognized by the machine.
;	/FULL_SIZE
;		Switch, if set, the output is full size.
;	/HALF_SIZE
;		Switch.  If set, the size of the output is (roughly) halved.
;	/QUARTER_SIZE
;		Switch.  If set, the size of the output is (roughly) cut to a quarter.
;	/BLIN_SIZE
;		Switch.  If set, the size of the output is set to a size intermediate
;		between "half" and "quarter".
;
;	Note:	If none of the size keywords is set, the size will be whatever is
;			currently specified for the selected output device.
;	/COLOR
;		Switch.  Specifies color output, when valid.
;	/PRINT
;		Switch.  Specifies sending the file to the printer, for the cases where
;		a file is generated ("PS" and "EPS").  Ignored for the "PRINTER" device.
;		Valid only with "WIN" OS.
;	SUBST
;		Accepts a string containing the names of the variables which are to
;		receive the values V_0 through V_15 (or part of them) for substitution
;		purposes.  Commas and/or spaces are valid delimiters.
;	_EXTRA
;		A formal keyword, used to pass keywords to FILE_GET.  Active only when
;		in PS or EPS mode.
; OUTPUTS:
;		None, other then the file that's created and whatever outputs are
;		generated by COMM.
; OPTIONAL OUTPUT PARAMETERS:
;		None.
; COMMON BLOCKS:
;		M_OUT_PREFS.  Contains the name of the last device used.
; SIDE EFFECTS:
;		OUTPUT tries to avoid any side effects, as far as possible.
;		Specifically, the values of all the system variables are reset at exit
;		from OUTPUT to the values they had before output was called.  Still,
;		since COMM can be any possible command, side effects cannot be totally
;		avoided.
;		A currently known side effect has to do with PostScript printers.  If
;		either COMM or OPTION change the postscipt settings, the new settings
;		will remain in effect after OUTPUT exits.
; RESTRICTIONS:
;		1) Currently the number of substitution variables is limited to 16.  If
;		it'll turn out that this number isn't sufficient it can be easily
;		increased.  Let me know.
;		2) The commands in COMM (and OPTION) shouldn't change the output device
;		(i.e. NO using SET_PLOT, DEVICE/CLOSE, etc., all this is taken care of
;		by OUTPUT).  If they do, no error will result but the outcome will be
;		unpredictable.
;		3) In order to make the best use of OUTPUT it is recommended that the
;		commands in COMM will be totally device independent (i.e. no using
;		explicit device coordinates etc.).  This allows to send the output of
;		the same procedure to the various printers and get consistent results.
;		If one finds it necessery to use some device specific commands (like
;		setting a color table for aprinter), they should be put in OPTION
;		(that's really the whole purpose of having OPTION)
; PROCEDURE:
;		OUTPUT contains a list of the appropriate device opening and closing
;		commands for the devices it recognizes.  When called, it does the
;		following.
;		1)  Checks DEVICE and if recognizable generates the appropriate OPEN,
;		CLOSE and PRINTOUT commands.
;		2)  Performs variable substitution if so specified (by a non-blank
;		value of SUBST)
;		3)  Opens device.
;		4)  Executes OPTION, if given.
;		5)  Executes COMM
;		6)  Closes device.
;		7)  Optionally (for file-generating devices) prints out the file.
;
;		OUTPUT uses various routines from MIDL, namely: DEFAULT, FILE_GET,
;		ONE_OF, PLVAR_KEEP, STREQ, STRMATCH_MM, STRPARSE_MM and TYPE.
; MODIFICATION HISTORY:
;		Created 15-JUL-1991 by Mati Meron.
;		Updated 5-FEB-2001 by Mati Meron.  Major rewrite, converting OUTPUT
;		from VMS specific to a generic routine.
;		Updated 10-MAY-2002 by Mati Meron.  Added keyword HALF_SIZE.
;		Updated 15-JUN-2002 by Mati Meron.  Added keyword QUARTER_SIZE.
;		Updated 15-JUN-2003 by Mati Meron.  Increased number of substitution
;		variables from 8 to 16.
;		Update, 25-DEC-2004 by Mati Meron.  Added interactive file selection
;		and keyword _EXTRA.
;-

	common m_out_prefs, outdev

	posib = ['Printer','PS', 'EPS']
	ext   = [ '','.ps','.eps']
	fcod =  [0,1,1]
	opcom = ['set_plot, "printer" &device,/landscape', $
		'set_plot, "PS" &device,/landscape,file=outfile', $
		'set_plot, "PS" &device,prev=2,/portrait,/encapsulated,file=outfile']
	clcom = ['device, /close', 'device, /close', 'device, /close']
	npos = n_elements(posib)

	on_error, 1
	if Type(comm) ne 7 then message, 'No command on line!'
	outdev = Default(dev,Default(outdev,'printer'),/strict)
	ndev = StrMatch_mm(outdev,posib,2)
	if ndev eq -1 then message, 'Unacceptable device!'
	if fcod(ndev) then begin
		if Type(fil) ne 7 then begin
			dum = Strparse_mm(systime(),' :',lis)
			outfile = lis[1]+'-'+lis[2]+'-'+lis[6]+'_'+lis[3]+lis[4]+lis[5]
		endif else outfile = fil
		wext = ext(ndev)
		if Strparse_mm(outfile,'.') eq 0 then outfile = outfile + wext
		outfile = $
		File_get(outfile,/wri,/over,def=strmid(wext,1),stat=stat,_extra=_e)
		if not stat then message, 'No file to write to!'
	endif else if keyword_set(sel) then dum = dialog_printersetup()

	if Type(sub) eq 7 then begin
		vnum = Strparse_mm(sub,' ,',vlist)
		if n_params() gt (vnum + 1) then begin
			snams = strcompress('v_' + sindgen(vnum+1),/remove)
			for i_v = 0, vnum do idum = execute(vlist(i_v) + ' = ' + snams(i_v))
		endif else message, 'Insuficient number of substitution variables!'
	endif

	Plvar_keep, action = 'save'

	dum = execute(opcom(ndev))
	hqs = One_of(ful,hlf,qua,bln)
	case hqs of
		0	:	dum = execute('device,/inch,xsiz=9.5,ysiz=7')
		1	:	dum = execute('device,/inch,/port,xsiz=7,ysiz=5')
		2	:	dum = execute('device,/inch,xsiz=5,ysiz=3.5')
		3	:	dum = execute('device,/inch,xsiz=5,ysiz=5')
		else:
	endcase

	if keyword_set(col) then begin
		if !d.name eq 'PRINTER' then dum = execute('device,/true_color') $
		else if !d.name eq 'PS' then dum = execute('device, /color')
		tvlct, red, gre, blu, /get
	endif

	if Type(opt) ne 7 then comstat= 1 else comstat= execute(opt)
	if comstat then comstat = execute(comm)
	if Type(red) ne 0 then tvlct, red, gre, blu
	dum = execute(clcom(ndev))

	if comstat and fcod(ndev) then begin
		print, 'Saved  ' + file_expand_path(outfile)
		if keyword_set(prn) and Streq(!version.os,'win',3) then begin
			set_plot, 'win'
			device, print_file = outfile
		endif
	endif

	Plvar_keep, action = 'restore'

	if not comstat then message, 'Command errors!', /continue
	return
end
