Function Shape_clean_old, shape, close = clo, tol_mult = tml

;+
; NAME:
;		SHAPE_CLEAN
; VERSION:
;		8.11
; PURPOSE:
;		Modifies a SHAPE (see SHAPE_VER for a definition) by removing dangling
;		zero area "tails" and repeated points.
; CATEGORY:
;		General Graphics.
; CALLING SEQUENCE:
;		Result = SHAPE_CLEAN( SHAPE, [, CLOSE = CLOSE])
; INPUTS:
;	SHAPE
;		Two dimensional shape i.e. a [2,*] numeric array.
; OPTIONAL INPUT PARAMETERS:
;		None.
; KEYWORD PARAMETERS:
;	/CLOSE
;		Switch.  If set, forces closure of the output shape.  If the input
;		shape happens to be closed, the output one is being closed
;		automatically unless CLOSE is explicitly set to zero.
;	TOL_MULT
;		Numeric scalar, tolerance multiplier to be used by the function APPROX.
;		See there for details.
; OUTPUTS:
;		Returns a new shape, generated by removing repeated points and zero area
;		closed loops from the original shape.
;		
;		Note:  The returned shape will always have at least 2 points, even if
;		they're identical.  An input shape with less than 3 points won't be
;		processed.
; OPTIONAL OUTPUT PARAMETERS:
; 		None.
; COMMON BLOCKS:
;		None.
; SIDE EFFECTS:
;		None.
; RESTRICTIONS:
;		Shapes with less than 3 points are returned uprocessed.
; PROCEDURE:
; 		Identifies spurious points and zero area loops and removes them.
; 		Repeats the process iteratively till no further modifications occur.
; 		Calls APPROX, DEFAULT, DIF, SHAPE_CLOSE, SHAPE_VER and TOLER from MIDL.
; MODIFICATION HISTORY:
;		Created 5-SEP-2011 by Mati Meron.
;		Modified 10-SEP-2011 by Mati Meron. Significant rewriting.
;-

	on_error, 1

	wtml = Default(tml,1) > 1
	res = shape
	ndim = Shape_ver(res,length=len)
	if ndim eq 2 then begin
		eps = 2*wtml*Toler(res)
		tre = eps*(max(abs(res[0,*])) + max(abs(res[1,*])))
		clf = Approx(res[*,0],res[*,len-1],thre=tre,/glob)
		tre = 0	
		con = len gt 2
		while con and len gt 2 do begin
			jlen = len + 2*clf
			j = lindgen(len)
			if clf then j = [len-1,j,0]
			dx = Dif(reform(res[0,j]))
			dy = Dif(reform(res[1,j]))
			if tre eq 0 then tre = 4*eps*max(abs(dx))*max(abs(dy))
			fir = dx*shift(dy,-1)
			sec = shift(dx,-1)*dy
			comp =  Approx(abs(fir),abs(sec),thre=tre)
			comp[0] = (comp[jlen-1]  = 0)
			comp = comp[clf:jlen-1-clf]
			bad = (where(comp))[0]
			if bad ge 0 then begin
				stat = replicate(1,len)
				stat[bad] =  0
				res = res[*,where(stat)]
				len = len - 1
			endif else con = 0
		endwhile	
		if (clf and Default(clo,1,/dtyp) ne 0) or keyword_set(clo) $
		then res = Shape_close(res)
	endif else begin			
		if ndim eq 3 then message, 'Only 2-D shapes accepted!', /continue $
		else message, 'Improper or missing shape!', /continue
		res = 0
	endelse

	return, res
end