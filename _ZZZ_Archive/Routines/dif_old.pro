Function Dif_old, vec, ord, backward = back, centered = cent, forward = forw, $
    edge_extend = edx, lin_extend = ldx, clip = cli

;+
; NAME:
;		DIF
; VERSION:
;		7.15
; PURPOSE:
;		Calculates finite differences for 1D vectors.
; CATEGORY:
;		Mathematical, general.
; CALLING SEQUENCE:
;		Result = DIF( VEC [, ORD] [, keywords])
; INPUTS:
;	VEC
;		1-D numeric array (a scalar may be used and it is treated as a vector
;		with length of 1.
; OPTIONAL INPUT PARAMETERS:
;	ORD
;		The order of the difference.  Default value is 1.
; KEYWORD PARAMETERS:
;	/BACKWARD
;		Switch.  If set, backward difference is performed, i.e.
;		Result[n] = VEC[n] - VEC[n-1].  This is also the default.
;	/FORWARD
;		Switch.  If set, forward difference is performed, i.e.
;		Result[n] = VEC[n+1] - VEC[n].
;	/CENTERED
;		Switch.  If set, centered difference is performed, i.e.
;		Result[n] = (VEC[n+1] - VEC[n-1])/2.
;
;		Note:	Only one of BACKWARD, FORWARD and CENTERED may be set at any
;				given call.
;
;	/EDGE_EXTEND
;		Switch.  If set, the "beyond the edge" elements which are needed for
;		the differences are set equal to the appropriate edge elements.  The
;		default operation is to set them to 0.
;	/LIN_EXTEND
;		Switch.  If set, the "beyond the edge" elements (see above) are
;		generated by linear propagation of the edge elements.
;
;		Note:	Only one of /EDGE_EXTEND and /LIN_EXTEND may be used.
;	/CLIP
;		Switch.  If set, the elements (within ORD from either edge) for which
;		there is not enough information to determine the result, are set to 0.
; OUTPUTS:
;		Returns the difference vector for VEC, of a type determined by the
;		keywords.
; OPTIONAL OUTPUT PARAMETERS:
;		None.
; COMMON BLOCKS:
;		None.
; SIDE EFFECTS:
;		None.
; RESTRICTIONS:
;		As mentioned above, Only one of BACKWARD/FORWARD/CENTERED may be used.
; PROCEDURE:
;		Straightforward.  Calls DEFAULT, FPU_FIX, ISNUM and ONE_OF from MIDL.
; MODIFICATION HISTORY:
;		Created 15-APR-2001 by Mati Meron.
;		Modified 25-MAR-2010 by Mati Meron.  Slight internal changes.
;-

	on_error, 1

	if Isnum(vec,type=typ) then wec = reform(vec) $
	else message, 'No input or non-numeric input!
	if (size(wec))(0) le 1 then n = n_elements(wec) else message, 'Bad input!'
	nord = Default(ord,1l,/dtyp) > 0
	dift = One_of(back,cent,forw) > 0

	if nord gt 0 then begin
		case One_of(edx,ldx) of
			-1:	res = [make_array(nord,type=typ),wec,make_array(nord,type=typ)]
			0 :	res = [replicate(wec[0],nord),wec,replicate(wec[n-1],nord)]
			1 :	begin
					dum = Cast(findgen(nord),typ,typ)
					bot = (wec[1<(n-1)] - wec[0])*(dum-nord) + wec[0]
					top = (wec[n-1] - wec[(n-2)>0])*(dum+1) + wec[n-1]
					res = [bot,wec,top]
				end
		endcase

		case dift of
			0	:	for k = 1, nord do res = res - shift(res,1)
			1	:	for k = 1, nord do res = 0.5*(shift(res,-1) - shift(res,1))
			2	:	for k = 1, nord do res = shift(res,-1) - res
		endcase

		if keyword_set(cli) then begin
			tres = res
			res = make_array(size=size(tres))
			lh = [0,n-1] + nord*(([5,2] - dift)/2)
			if lh[0] le lh[1] then res[lh[0]:lh[1]] = tres[lh[0]:lh[1]]
		endif
	endif else res = wec

	return, FPU_FIX(res[nord:n+nord-1])
end